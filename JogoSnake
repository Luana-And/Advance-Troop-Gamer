int cols = 20;
int rows = 20;
int cellSize = 20;

Snake snake;
PVector food;
boolean gameOver = false;
boolean telaIntroducao = true; // começa no menu

// Botões
int buttonX, buttonY, buttonW = 150, buttonH = 40;

// Modo de dificuldade (afeta frameRate)
String dificuldade = "";

void settings() {
  size(cols * cellSize, rows * cellSize);
}

void setup() {
  mostrarIntroducao();
}

void draw() {
  background(0);

  if (telaIntroducao) {
    mostrarMenu();
  } else if (!gameOver) {
    snake.move();
    snake.checkCollision();
    snake.show();

    fill(255, 0, 0);
    rect(food.x * cellSize, food.y * cellSize, cellSize, cellSize);

    if (snake.head().equals(food)) {
      snake.grow();
      spawnFood();
    }
  } else {
    mostrarGameOver();
  }
}

void mostrarMenu() {
  fill(255);
  textSize(24);
  textAlign(CENTER, CENTER);
  text("A cobra precisa comer muito!\n\nEla está com muita fome e precisa crescer para sobreviver.", width/2, height/4);

  // Botões de dificuldade centralizados
  String[] modos = {"Fácil", "Normal", "Difícil"};
  int startY = height/2 - 80;
  for (int i = 0; i < modos.length; i++) {
    buttonX = width / 2 - buttonW / 2;
    buttonY = startY + i * (buttonH + 20);

    fill(50, 150, 50);
    rect(buttonX, buttonY, buttonW, buttonH, 10);

    fill(255);
    textSize(20);
    textAlign(CENTER, CENTER);
    text(modos[i], buttonX + buttonW/2, buttonY + buttonH/2);
  }
}

void mousePressed() {
  if (telaIntroducao) {
    // Verifica clique nos botões de dificuldade
    String[] modos = {"Fácil", "Normal", "Difícil"};
    int startY = height/2 - 80;

    for (int i = 0; i < modos.length; i++) {
      buttonX = width / 2 - buttonW / 2;
      buttonY = startY + i * (buttonH + 20);

      if (mouseX >= buttonX && mouseX <= buttonX + buttonW &&
          mouseY >= buttonY && mouseY <= buttonY + buttonH) {
        dificuldade = modos[i];
        iniciarJogo();
        break;
      }
    }
  } else if (gameOver) {
    // Botão reiniciar no game over - volta para menu
    if (mouseX >= buttonX && mouseX <= buttonX + buttonW &&
        mouseY >= buttonY && mouseY <= buttonY + buttonH) {
      mostrarIntroducao();
    }
  }
}

void iniciarJogo() {
  telaIntroducao = false;
  snake = new Snake();
  spawnFood();
  gameOver = false;

  // Ajusta frameRate conforme dificuldade
  if (dificuldade.equals("Fácil")) {
    frameRate(5);
  } else if (dificuldade.equals("Normal")) {
    frameRate(10);
  } else if (dificuldade.equals("Difícil")) {
    frameRate(15);
  }
  loop();
}

void spawnFood() {
  food = new PVector(floor(random(cols)), floor(random(rows)));
  while (snake.contains(food)) {
    food = new PVector(floor(random(cols)), floor(random(rows)));
  }
}

void keyPressed() {
  if (gameOver || telaIntroducao) return;

  if ((key == 'w' || key == 'W') && snake.ydir != 1) {
    snake.setDir(0, -1);
  } else if ((key == 's' || key == 'S') && snake.ydir != -1) {
    snake.setDir(0, 1);
  } else if ((key == 'a' || key == 'A') && snake.xdir != 1) {
    snake.setDir(-1, 0);
  } else if ((key == 'd' || key == 'D') && snake.xdir != -1) {
    snake.setDir(1, 0);
  }
}

void mostrarGameOver() {
  background(0);
  fill(255, 0, 0);
  textSize(32);
  textAlign(CENTER, CENTER);
  text("Game Over!", width / 2, height / 2 - 60);

  // Botão reiniciar para voltar ao menu
  buttonX = width / 2 - buttonW / 2;
  buttonY = height / 2;
  fill(50, 200, 50);
  rect(buttonX, buttonY, buttonW, buttonH, 10);

  fill(255);
  textSize(20);
  textAlign(CENTER, CENTER);
  text("Reiniciar", buttonX + buttonW / 2, buttonY + buttonH / 2);
}

void mostrarIntroducao() {
  telaIntroducao = true;
  gameOver = false;
  noLoop(); // pausa o jogo até o modo ser escolhido
}

// Classe Snake
class Snake {
  ArrayList<PVector> body;
  int xdir = 1;
  int ydir = 0;

  Snake() {
    body = new ArrayList<PVector>();
    body.add(new PVector(floor(cols / 2), floor(rows / 2)));
    xdir = 1;
    ydir = 0; 
  }

  void setDir(int x, int y) {
    if (body.size() > 1) {
      PVector head = body.get(0);
      PVector neck = body.get(1);
      if (head.x + x == neck.x && head.y + y == neck.y) return;
    }
    xdir = x;
    ydir = y;
  }

  void move() {
    if (xdir == 0 && ydir == 0) return;

    PVector head = body.get(0).copy();
    head.x += xdir;
    head.y += ydir;
    body.add(0, head);
    body.remove(body.size() - 1);
  }

  void grow() {
    PVector head = body.get(0).copy();
    head.x += xdir;
    head.y += ydir;
    body.add(0, head);
  }

  void show() {
    fill(0, 255, 0);
    for (PVector part : body) {
      rect(part.x * cellSize, part.y * cellSize, cellSize, cellSize);
    }
  }

  PVector head() {
    return body.get(0);
  }

  boolean contains(PVector pos) {
    for (PVector part : body) {
      if (part.equals(pos)) return true;
    }
    return false;
  }

  void checkCollision() {
    PVector head = body.get(0);
    if (head.x < 0 || head.x >= cols || head.y < 0 || head.y >= rows) {
      encerrarJogo();
    }

    for (int i = 1; i < body.size(); i++) {
      if (head.equals(body.get(i))) {
        encerrarJogo();
      }
    }
  }

  void encerrarJogo() {
    gameOver = true;
    noLoop();
  }
}
